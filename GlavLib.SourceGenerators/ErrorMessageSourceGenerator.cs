using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Text;
using GlavLib.SourceGenerators.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using YamlDotNet.Serialization;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace GlavLib.SourceGenerators;

[Generator]
public class ErrorMessageSourceGenerator : IIncrementalGenerator
{
    private static readonly Deserializer YamlDeserializer = new();

    private const string ErrorMessageNamespace = "GlavLib.Basics.Errors";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var translations = context.AdditionalTextsProvider
                                  .Where(text => text.Path.EndsWith("Errors.yaml",
                                                                    StringComparison.OrdinalIgnoreCase))
                                  .Select((text, ct) => text.GetText(ct)?.ToString())
                                  .Where(text => text is not null)!
                                  .Collect<string>();

        context.RegisterSourceOutput(translations, GenerateCode);
    }

    private static void GenerateCode(SourceProductionContext context,
                                     ImmutableArray<string>  errorYamls)
    {
        foreach (var errorYamlText in errorYamls)
        {
            var errorsBundle = YamlDeserializer.Deserialize<ErrorsBundle>(errorYamlText);

            var bundleClassSource = GenerateErrorsClassSource(errorsBundle);

            context.AddSource($"{errorsBundle.ClassName}.g.cs", SourceText.From(bundleClassSource, Encoding.UTF8));
        }
    }

    private static string GenerateErrorsClassSource(ErrorsBundle errorsBundle)
    {
        var fields     = new List<MemberDeclarationSyntax>();
        var methods    = new List<MemberDeclarationSyntax>();
        var argClasses = new List<MemberDeclarationSyntax>();

        foreach (var kvp in errorsBundle.Errors)
        {
            var errorName = kvp.Key;
            var message   = kvp.Value;

            var messageTemplate = ErrorMessageTemplate.Parse(message);

            if (messageTemplate.ParameterNames.Count == 0)
            {
                var field =
                    $"public static readonly ErrorMessage {errorName} = new (\"{errorName}\", \"{messageTemplate.InterpolatedMessage}\");";
                fields.Add(ParseMemberDeclaration(field)!);
            }
            else
            {
                var messageFunction = BuildMessageFunction(errorName, messageTemplate);
                var argClass        = BuildMessageArgsClass(errorName, messageTemplate);

                methods.Add(messageFunction);
                argClasses.Add(argClass);
            }
        }

        var compilationUnit = CompilationUnit()
            .AddUsings(UsingDirective(IdentifierName(ErrorMessageNamespace)));

        var bundleClass = ClassDeclaration(errorsBundle.ClassName)
                          .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword))
                          .AddMembers(fields.ToArray())
                          .AddMembers(methods.ToArray())
                          .AddMembers(argClasses.ToArray());

        var ns = errorsBundle.Namespace;
        if (string.IsNullOrWhiteSpace(ns))
        {
            compilationUnit = compilationUnit.AddMembers(bundleClass);
        }
        else
        {
            var namespaceDeclaration = NamespaceDeclaration(IdentifierName(ns!));
            namespaceDeclaration = namespaceDeclaration.AddMembers(bundleClass);

            compilationUnit = compilationUnit.AddMembers(namespaceDeclaration);
        }

        return compilationUnit.NormalizeWhitespace()
                              .WithLeadingTrivia(ParseLeadingTrivia("/// <auto-generated/>\n"))
                              .ToFullString();
    }

    private static MemberDeclarationSyntax BuildMessageFunction(string errorName, ErrorMessageTemplate messageTemplate)
    {
        var argumentsSb         = new StringBuilder();
        var fieldsInitializerSb = new StringBuilder();

        var argumentNames = messageTemplate.ArgumentNames;
        for (var i = 0; i < argumentNames.Count; i++)
        {
            var argumentName  = argumentNames[i];
            var parameterName = messageTemplate.ParameterNames[i];
            var typeName      = messageTemplate.ParameterTypes[i];

            argumentsSb.Append(typeName);
            argumentsSb.Append(' ');
            argumentsSb.Append(argumentName);

            fieldsInitializerSb.Append(parameterName);
            fieldsInitializerSb.Append(" = ");
            fieldsInitializerSb.Append(argumentName);

            if (i < argumentNames.Count - 1)
            {
                argumentsSb.Append(", ");
                fieldsInitializerSb.AppendLine(", ");
            }
        }

        var argsInstance = $$"""
                             var args = new {{errorName}}Args
                             {
                                 {{fieldsInitializerSb}}
                             };
                             """;

        var method = $$"""
                       public static ErrorMessage {{errorName}}({{argumentsSb}})
                       {
                          {{argsInstance}}
                       
                          var message = $"{{messageTemplate.InterpolatedMessage}}";
                          return new ErrorMessage("{{errorName}}", message, args);
                       }
                       """;

        return ParseMemberDeclaration(method)!;
    }

    private static ClassDeclarationSyntax BuildMessageArgsClass(string errorName, ErrorMessageTemplate messageTemplate)
    {
        var properties = new List<MemberDeclarationSyntax>();

        var argumentNames = messageTemplate.ArgumentNames;
        for (var i = 0; i < argumentNames.Count; i++)
        {
            var parameterName = messageTemplate.ParameterNames[i];
            var typeName      = messageTemplate.ParameterTypes[i];

            var propertyText = $"public required {typeName} {parameterName} {{ get; init; }}";

            var property = ParseMemberDeclaration(propertyText);
            properties.Add(property!);
        }

        return ClassDeclaration($"{errorName}Args")
               .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.SealedKeyword))
               .AddMembers(properties.ToArray());
    }

    [SuppressMessage("ReSharper", "UnusedAutoPropertyAccessor.Local")]
    [SuppressMessage("ReSharper", "AutoPropertyCanBeMadeGetOnly.Local")]
    private sealed class ErrorsBundle
    {
        public string? Namespace { get; set; }

        public string ClassName { get; set; } = null!;

        public IDictionary<string, string> Errors { get; set; } = null!;
    }
}